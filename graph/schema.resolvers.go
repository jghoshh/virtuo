package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/jghoshh/virtuo/auth"
	"github.com/jghoshh/virtuo/contextKey"
	"github.com/jghoshh/virtuo/graph/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, user model.UserInput) (*model.AuthPayload, error) {
	if len(user.Username) < 2 {
		return nil, fmt.Errorf("username must be at least 2 characters")
	}

	if !ValidateEmail(user.Email) {
		return nil, fmt.Errorf("invalid email format")
	}

	if !ValidatePassword(user.Password) {
		return nil, fmt.Errorf("password must be at least 8 characters and contain both letters and numbers")
	}

	token, refreshToken, err := auth.SignUp(user.Username, user.Email, user.Password)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "400",
			},
		})
		return nil, nil
	}

	authPayload := &model.AuthPayload{
		Token:        token,
		RefreshToken: refreshToken,
	}

	return authPayload, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	token, refreshToken, err := auth.SignIn(username, password)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Path:    graphql.GetPath(ctx),
			Message: "invalid username or password",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return nil, nil
	}

	authPayload := &model.AuthPayload{
		Token:        token,
		RefreshToken: refreshToken,
	}

	return authPayload, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (bool, error) {
	result := true
	return result, nil
}

// RefreshAccessToken is the resolver for the refreshAccessToken field.
func (r *mutationResolver) RefreshAccessToken(ctx context.Context, refreshToken string) (*model.AuthPayload, error) {
	_, ok := ctx.Value(contextKey.JwtErrorKey).(error)

	if ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "user unauthenticated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return nil, nil
	}

	userId, ok := ctx.Value(contextKey.UserIDKey).(string)

	if !ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "user unauthenticated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return nil, nil
	}

	token, refreshToken, err := auth.RefreshToken(userId, refreshToken)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})

		return nil, nil
	}

	authPayload := &model.AuthPayload{
		Token:        token,
		RefreshToken: refreshToken,
	}

	return authPayload, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	_, ok := ctx.Value(contextKey.JwtErrorKey).(error)

	if ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "user unauthenticated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return nil, nil
	}

	userId, ok := ctx.Value(contextKey.UserIDKey).(string)

	if !ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "user unauthenticated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return nil, nil
	}

	// Ensure currentPassword is provided
	if input.CurrentPassword == "" {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "current password must be provided",
			Extensions: map[string]interface{}{
				"code": "400",
			},
		})
		return nil, nil
	}

	// Ensure at least one of newEmail, newUsername, newPassword is provided
	if input.NewEmail == nil && input.NewUsername == nil && input.NewPassword == nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "at least one of new email, new username or new password must be provided",
			Extensions: map[string]interface{}{
				"code": "400",
			},
		})
		return nil, nil
	}

	var newUsernameStr, newEmailStr, newPasswordStr string

	if input.NewUsername != nil {
		if len(*input.NewUsername) <= 1 {
			graphql.AddError(ctx, &gqlerror.Error{
				Message: "username must be at least 2 characters",
				Extensions: map[string]interface{}{
					"code": "400",
				},
			})
			return nil, nil
		}
		newUsernameStr = *input.NewUsername
	}

	if input.NewEmail != nil {
		if !ValidateEmail(*input.NewEmail) {
			graphql.AddError(ctx, &gqlerror.Error{
				Message: "invalid email format",
				Extensions: map[string]interface{}{
					"code": "400",
				},
			})
			return nil, nil
		}
		newEmailStr = *input.NewEmail
	}

	if input.NewPassword != nil {
		if !ValidatePassword(*input.NewPassword) {
			graphql.AddError(ctx, &gqlerror.Error{
				Message: "password must be at least 8 characters and contain both letters and numbers",
				Extensions: map[string]interface{}{
					"code": "400",
				},
			})
			return nil, nil
		}
		newPasswordStr = *input.NewPassword
	}

	user, err := auth.UpdateUser(userId, input.CurrentPassword, newUsernameStr, newEmailStr, newPasswordStr)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: err.Error(),
			Extensions: map[string]interface{}{
				"code": "400",
			},
		})
		return nil, nil
	}

	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context) (bool, error) {
	_, ok := ctx.Value(contextKey.JwtErrorKey).(error)

	if ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "User unauthenticated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return false, nil
	}

	userId, ok := ctx.Value(contextKey.UserIDKey).(string)

	if !ok {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "User unauthenicated",
			Extensions: map[string]interface{}{
				"code": "401",
			},
		})
		return false, nil
	}

	res, err := auth.DeleteUser(userId)

	if err != nil {
		graphql.AddError(ctx, &gqlerror.Error{
			Message: "Failed to delete user",
			Extensions: map[string]interface{}{
				"code": "500",
			},
		})
		return false, nil
	}

	return res, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
